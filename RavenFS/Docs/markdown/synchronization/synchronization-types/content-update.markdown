#Content update

There are two types of modifications of the file system that are considered as a file content update:

* upload a new file,
* upload a file with changed content.

In the first case we have to transfer entire file of course. The second case is a bit more complex, next sections of this chapter explain a solution to handle that.

##How to detect that content has changed?

Every time that we upload a file RavenFS calculates its hash on the fly. It uses MD5 algorithm and after a successful upload the value is stored in metadata as *Content-MD5*.
It allows to determine whether contents of the files are different or not just by metadata comparison. Note that after the synchronization of file content the hash is calculated as well.

##Remote Differential Compression

The purpose of RavenFS is to synchronize large files in an efficient way by minimizing the amount of data transferred between source and destination servers. 
In order to achieve that RavenFS uses Remote Differential Compression (RDC), the built-in Windows feature. Below are presented just basics of RDC that allow you to understand how RavenFS works. 
To explore RDC in much more detail take a look [here](http://msdn.microsoft.com/en-us/library/dd357428%28v=prot.20%29.aspx).

###Overview

Remote Differential Compression takes care of detection what parts of the file are different and which ones are the same. There is a list created called *need list* whose items describe how to construct the final file on the destination server.
Each item consists of an accurate byte range and information which version of the file ('source' or 'seed') it concerns. Based on the need list the source server pushes all file parts marked as 'source' to the destination. 
There transferred data and existing file data (marked as 'seed' on the list) are combined in the order they appear on the need list to create the synchronized file.

RDC is able to calculate the mentioned byte ranges very precisely what allows to reduce the amount of sent data, especially when a small changes of file content were made or just some new data was appended.

###Signatures

RDC breaks a file into chunks. Each chunk has an assigned hash value that together with the chunk size create a *signature*. A collection of file signatures has full information about file content. 
The source server retrieves the information about the file on the destination by downloading a *signature file* that contains all destination file signatures. By using own signature file and the one downloaded from destination, the source is able to generate need list.

{INFO For a really large file a signature file may be quite big too. Therefore it is not downloaded as a whole. RavenFS internally also synchronizes the signatures to speed up the entire operation and reduce exchanged data. /}

##Transfer format

An upload of missing file chunks between a source and a destination is performed by using HTTP multipart POST message. The destination server exposes `/synchronization/multipartproceed` endpoint which accepts only RavenFS specific formatted MIME multipart content. 
Below there is a sample synchronization request generated by the source server (`Content-Type` request header has to be set as `multipart/form-data; boundary=syncing`).

	--syncing

	Content-Disposition: form-data; Syncing-need-type=seed; Syncing-range-from=0; 
	Syncing-range-to=407029
	Content-Type: plain/text


	--syncing
	Content-Disposition: file; Syncing-need-type=source; Syncing-range-from=407030; 
	Syncing-range-to=412242
	Content-Type: application/octet-stream

	[... data from byte 407030 to 412242 goes here...]

	--syncing--

Note that first `seed` part is empty because it involves the destination file version, it contains only information about byte range that needs to be copied from the existing file. 
The second one `source` except from byte range contains the file part data. 

If the file does not exist on the destination the message consists of only one `source` part that contains the entire file content.

##Temporary downloading file

RavenFS assumes that an error during the synchronization operation might happen at any time. Hence to avoid a situation where the failed synchronization brakes your file, in the middle of executing the synchronization
on a destination server we build the final file without removing the old one. The synchronized file is constucted as `filename.downloading`. If the synchronization finishes without any errors `filename` will be deleted and `filename.downloading` renamed to `filename`.